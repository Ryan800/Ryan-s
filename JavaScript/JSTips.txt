1.NaN 与所有其他值都不想等，包括他自己 NaN === NaN; //false
2.数组能放任意形式的元素a,[1, 4.23, false, "Hello"] b,new Array(1, 2, false, true)
	length属性，
	indexOf(),
	slice()截取，不穿任何参数的话相当于复制array
	push() 末尾添加元素
	pop() 删除最后一个元素
	unshift() 头部添加元素
	shift() 删除第一个元素
	sort() 排序
	reverse() 反转
	splice(2, 3, 'Google', 'Facebook') 从第二个元素开始，删除3个元素，并添加后面两个元素。
	concat() 连接Array
	join("-") 用指定字符串连接每个元素(用"-"连接)
3.对象：键值组成的无序集合
	var person = {
		name:'Bob',
		age:20,
		tags:['js', 'web', 'mobile'],
		city:'Beijing',
		hasCar:true,
		zipcode:null
	};
	delete person.name 删除某一属性
	'Bob' in xiaoming; //true in 检测是否有某一属性（继承的也算）
	hasOwnProperty() 自身拥有的 person.hasOwnProperty('Bob');
4.启用strict模式的方法是在JavaScript代码的第一行写上：
	'use strict'; //强制var声明，如果不用var声明，则会报错。
5.indexOf(),substring()
6.js把null,undefined,0,Nan,'' 视为false，其他一概视为true
7.Map var map = new Map([["Michael", 34], ["Bob", 53], ["wang", 63]]);
	map.set("bing", 93);
	map.get("bing");
	map.delete("bing");
	key value 数据类型任意
8.Set var set = new Set([3, 4, null, 'wang']);
	set.add(4);
	set.delete(null);
9.iterable for ... of ...
10.函数 function 
	arguments
	rest
	js不支持块级作用域，只支持函数作用域，let，const使其支持块级作用域。
11.方法--绑定在对象中的函数，成为这个对象的方法。
	apply() 指定函数的this指向的对象
	另一个与apply()类似的方法是call()，唯一区别是：
	apply()把参数打包成Array再传入；
	call()把参数按顺序传入。

	利用apply()，我们还可以动态改变函数的行为。
	JavaScript的所有对象都是动态的，即使内置的函数，我们也可以重新指向新的函数。
	现在假定我们想统计一下代码一共调用了多少次parseInt()，可以把所有的调用都找出来，然后手动加上count += 1，不过这样做太傻了。最佳方案是用我们自己的函数替换掉默认的parseInt()：

	var count = 0;
	var oldParseInt = parseInt; // 保存原函数

	window.parseInt = function () {
	    count += 1;
	    return oldParseInt.apply(null, arguments); // 调用原函数
	};

	// 测试:
	parseInt('10');
	parseInt('20');
	parseInt('30');
	count; // 3
*高阶函数
